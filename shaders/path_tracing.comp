#version 460 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;


// STRUCTS

struct Sphere
{
	vec4 pos;
	vec4 clr;
	float r;
};



// OUPUT BUFFERS

layout(set = 0, binding = 0, std430) buffer ColorBuffer
{
	vec4 pixel[];
} color_buffer;

layout(set = 0, binding = 1, std430) buffer DebugBuffer
{
	float data[];
} debug_buffer;



// INPUT BUFFERS

layout(set = 1, binding = 0, std140) buffer Camera
{
	vec4 pos;
	vec4 rot;
	float fov;
} camera;

layout(set = 1, binding = 1, std430) buffer SphereBuffer
{
	Sphere[] sphere;
} sphere_buffer;


// FUNCTIONS

vec4 color(float x, float y)
{
	vec4 r1 = vec4(1, 1, 1, 1);
	vec4 r2 = vec4(0, 1, 1, 1);
	vec4 r3 = vec4(1, 0, 1, 1);
	vec4 r4 = vec4(1, 1, 0, 1);

	vec4 res = r1 * (1 - x) * (1 - y) + r2 * x * (1 - y) + r3 * (1 - x) * y + r4 * x * y;
	return res;
}

vec4 get_cam_ray(uint idx, uint idy, uint width, uint height)
{
	float dA;
	float dB;
	return vec4(1);
}   

void main()
{
	uint idx = gl_GlobalInvocationID.x;
	uint idy = gl_GlobalInvocationID.y;
	uint width = gl_NumWorkGroups.x;
	uint height = gl_NumWorkGroups.y;
	
	vec4 ray = get_cam_ray(idx, idy, width, height);
	float dx = float(idx) / width;
	float dy = float(idy) / height;
	color_buffer.pixel[idx + idy * width].rgba = color(dx, dy);

	// DEBUG

	// Print camera rotation
	// debug_buffer.data[0] = camera.rot.x;
	// debug_buffer.data[1] = camera.rot.y;
	// debug_buffer.data[2] = camera.rot.z;
}
