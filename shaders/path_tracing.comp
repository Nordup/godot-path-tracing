#version 460 core


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;




/* ====================== STRUCTS ====================== */


struct Sphere
{
	vec4 pos;
	float rad;
	vec4 clr;
	vec4 ems; // emission
	float refl; // reflection type (DIFFuse, SPECular, REFRactive)
};


struct Ray
{
	vec3 pos;
	vec3 dir;
};




/* ====================== OUPUT BUFFERS ====================== */


layout(set = 0, binding = 0, std430) buffer ColorBuffer
{
	vec4 pixel[];
} color_buffer;


layout(set = 0, binding = 1, std430) buffer DebugBuffer
{
	float data[];
} debug_buffer;




/* ====================== INPUT BUFFERS ====================== */


layout(set = 1, binding = 0, std430) buffer Globals
{
	float Depth;
	float TicksMsec;
};


layout(set = 2, binding = 0, std430) buffer Camera
{
	vec4 pos;
	vec4 rot;
	float fov;
} camera;


layout(set = 2, binding = 1, std430) buffer SphereBuffer
{
	Sphere[] sphere;
} sphere_buffer;




/* ====================== GLOBAL CONSTS ====================== */


const float PI = 3.14159265358979323846;


// Reflection type (DIFFuse, SPECular, REFRactive)

const float DIFF = 0;
const float SPEC = 1;
const float REFR = 2;


// Runtime global variables

uint idx = gl_GlobalInvocationID.x;
uint idy = gl_GlobalInvocationID.y;
uint width = gl_NumWorkGroups.x;
uint height = gl_NumWorkGroups.y;




/* ====================== FUNCTIONS ====================== */


// Debug

int pIndex = 0;


void print(float f)
{
	debug_buffer.data[pIndex] = 1;
	debug_buffer.data[pIndex + 1] = f;
	pIndex += 2;
}


void print4(vec4 vec)
{
	debug_buffer.data[pIndex] = 4;
	debug_buffer.data[pIndex + 1] = vec.x;
	debug_buffer.data[pIndex + 2] = vec.y;
	debug_buffer.data[pIndex + 3] = vec.z;
	debug_buffer.data[pIndex + 4] = vec.w;
	pIndex += 5;
}


// Main

vec2 seed = vec2(idx, idy) + TicksMsec / 1000;
float rand()
{
	vec3 p3  = fract(vec3(seed.xyx) * .1031);
	p3 += dot(p3, p3.yzx + 33.33);
	float result = fract((p3.x + p3.y) * p3.z);

	seed += result * 100;
	return result;
}


float intersect_sphere(const Ray ray, const Sphere sph)
{
	// returns distance, 0 if nohit
	// Solve t^2*d.d + 2*t*(o-p).d + (o-p).(o-p)-R^2 = 0
	vec3 op = sph.pos.xyz - ray.pos;
	float t, eps = 1e-4;
	float b = dot(op, ray.dir);
	float det = b * b - dot(op, op) + sph.rad * sph.rad;
	if (det < 0)
		return 0;
	else
		det = sqrt(det);
	return (t = b - det) > eps ? t : ((t = b + det) > eps ? t : 0);
}


bool intersect(const Ray ray, inout float t, inout int id)
{
	float d;
	float inf = t = 1e20;
	for (int i = 0; i < sphere_buffer.sphere.length(); i++)
	{
		d = intersect_sphere(ray, sphere_buffer.sphere[i]);
		if (d != 0 && d < t)
		{
			t = d;
			id = i;
		}
	}
	return t < inf;
}


vec3 radiance(Ray ray)
{
	float t; // distance to intersection
	int id = 0; // id of intersected object
	int depth = 0;

	vec3 cl = vec3(0); // accumulated color
	vec3 cf = vec3(1); // accumulated reflectance

	int unroll = int(Depth) * 5;
	while (unroll-- > 0)
	{
		if (!intersect(ray, t, id))
			return cl;
		const Sphere sph = sphere_buffer.sphere[id];

		vec3 hit = ray.pos + ray.dir * t; // hit point
		vec3 n = normalize(hit - sph.pos.xyz);
		vec3 nl = dot(n, ray.dir) < 0 ? n : n * -1;
		vec3 f = sph.clr.xyz;
		float p = max(max(f.x, f.y), f.z); // max refl

		cl = cl + cf * sph.ems.xyz;
		if (++depth > Depth)
			if (rand() < p)
				f = f * (1 / p);
			else
				return cl; // R.R.
		cf = cf * f;

		if (sph.refl == DIFF)
		{
			// Ideal DIFFUSE reflection

			float r1 = 2 * PI * rand();
			float r2 = rand();
			float r2s = sqrt(r2);
			vec3 w = nl;
			vec3 u = normalize(cross((abs(w.x) > .1 ? vec3(0, 1, 0) : vec3(1, 0, 0)), w));
			vec3 v = cross(w, u);
			vec3 dir = normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1 - r2));
			
			ray = Ray(hit, dir);

			continue; // return sph.ems + f * radiance(Ray(hit,dir),depth,Xi);
		}
		else if (sph.refl == SPEC)
		{
			// Ideal SPECULAR reflection

			ray = Ray(hit, ray.dir - n * 2 * dot(n, ray.dir));

			continue; // return sph.ems + f * radiance(Ray(hit,ray.dir-n*2*dot(n, ray.dir)),depth,Xi);
		}
		else
		{
			// Ideal dielectric REFRACTION

			Ray reflRay = Ray(hit, ray.dir - n * 2 * dot(n, ray.dir));
			bool into = dot(n, nl) > 0; // Ray from outside going in?
			
			float nc = 1;
			float nt = 1.5;
			float nnt = into ? nc / nt : nt / nc;
			float ddn = dot(ray.dir, nl);
			float cos2t;
			
			if ((cos2t = 1 - nnt * nnt * (1 - ddn * ddn)) < 0)
			{
				// Total internal reflection

				ray = reflRay;

				continue; // return sph.ems + f * radiance(reflRay,depth,Xi);
			}

			vec3 tdir = normalize(ray.dir * nnt - n * ((into ? 1 : -1) * (ddn * nnt + sqrt(cos2t))));
			
			float a = nt - nc;
			float b = nt + nc;
			float R0 = a * a / (b * b);
			float c = 1 - (into ? -ddn : dot(tdir, n));
			float Re = R0 + (1 - R0) * c * c * c * c * c;
			float Tr = 1 - Re;
			float P = .25 + .5 * Re;
			float RP = Re / P;
			float TP = Tr / (1 - P);
			
			if (rand() < P)
			{
				cf = cf * RP;
				ray = reflRay;
			}
			else
			{
				cf = cf * TP;
				ray = Ray(hit, tdir);
			}

			continue;	// return sph.ems + f * rand()<P ?
						//						radiance(reflRay,	depth,Xi)*RP:
						//						radiance(Ray(hit,tdir),depth,Xi)*TP;
		}
	}
}


Ray get_cam_ray(uint idx, uint idy)
{
	// TODO: randomize ray
	float fovA = radians(camera.fov / 2);
	float camX = sin(fovA);
	float camZ = -cos(fovA);
	float dX = 2 * camX / width;
	float dY = dX;
	float camY = (height / 2) * dY;

	vec3 baseRay = vec3(
		-camX + dX * idx,
		camY - dY * idy,
		camZ
	);

	// rotated_vec = vec + 2.0 * cross(cross(vec, quat.xyz) + quat.w * vec, quat.xyz)
	vec3 rotated = baseRay + 2.0 * cross(cross(baseRay, camera.rot.xyz) + camera.rot.w * baseRay, camera.rot.xyz);
	return Ray(camera.pos.xyz, normalize(rotated));
}


void main()
{
	float t;
	int id;

	Ray ray = get_cam_ray(idx, idy);
	color_buffer.pixel[idx + idy * width] = vec4(radiance(ray), 1);


	// Debug

	if (idx == 0 && idy == 0)
	{
	}
}
