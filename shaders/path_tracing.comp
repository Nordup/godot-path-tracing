#version 460 core


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;




/* ====================== STRUCTS ====================== */


struct Sphere
{
	float rad;
	vec4 pos;
	vec4 clr;
	vec4 ems; // emission
	float refl; // reflection type (DIFFuse, SPECular, REFRactive)
};


struct Ray
{
	vec3 pos;
	vec3 dir;
};




/* ====================== OUPUT BUFFERS ====================== */


layout(set = 0, binding = 0, std430) buffer ColorBuffer
{
	vec4 pixel[];
} color_buffer;


layout(set = 0, binding = 1, std430) buffer DebugBuffer
{
	float data[];
} debug_buffer;




/* ====================== INPUT BUFFERS ====================== */


layout(set = 1, binding = 0, std140) buffer Camera
{
	vec3 pos;
	vec4 rot;
	float fov;
} camera;


layout(set = 1, binding = 1, std430) buffer SphereBuffer
{
	Sphere[] sphere;
} sphere_buffer;




/* ====================== GLOBAL CONSTS ====================== */


uint idx = gl_GlobalInvocationID.x;
uint idy = gl_GlobalInvocationID.y;
uint width = gl_NumWorkGroups.x;
uint height = gl_NumWorkGroups.y;


// Reflection type (DIFFuse, SPECular, REFRactive)

const uint DIFF = 0;
const uint SPEC = 1;
const uint REFR = 2;



/* ====================== FUNCTIONS ====================== */


// Debug

int pIndex = 0;


void print(float f)
{
	debug_buffer.data[pIndex] = 1;
	debug_buffer.data[pIndex + 1] = f;
	pIndex += 2;
}


void print3(vec3 vec)
{
	debug_buffer.data[pIndex] = 3;
	debug_buffer.data[pIndex + 1] = vec.x;
	debug_buffer.data[pIndex + 2] = vec.y;
	debug_buffer.data[pIndex + 3] = vec.z;
	pIndex += 4;
}


void print4(vec4 vec)
{
	debug_buffer.data[pIndex] = 4;
	debug_buffer.data[pIndex + 1] = vec.x;
	debug_buffer.data[pIndex + 2] = vec.y;
	debug_buffer.data[pIndex + 3] = vec.z;
	debug_buffer.data[pIndex + 4] = vec.w;
	pIndex += 5;
}



// Main


vec3 get_cam_ray(uint idx, uint idy)
{
	float fovA = radians(camera.fov / 2);
	float camX = sin(fovA);
	float camZ = -cos(fovA);
	float dX = 2 * camX / width;
	float dY = dX;
	float camY = (height / 2) * dY;

	vec3 baseRay = vec3(
		-camX + dX * idx,
		camY - dY * idy,
		camZ
	);

	// rotated_vec = vec + 2.0 * cross(cross(vec, quat.xyz) + quat.w * vec, quat.xyz)
	vec3 rotated = baseRay + 2.0 * cross(cross(baseRay, camera.rot.xyz)
										+ camera.rot.w * baseRay, camera.rot.xyz);
	return rotated;
}


void main()
{
	vec3 ray = get_cam_ray(idx, idy);
	color_buffer.pixel[idx + idy * width] = vec4(ray, 1);


	// Debug

	if (idx == 0 && idy == 0)
	{
		for (int i = 0; i < sphere_buffer.sphere.length(); i++)
		{
			Sphere sph = sphere_buffer.sphere[i];

			print(sph.rad);
			print4(sph.pos);
			print4(sph.clr);
			print4(sph.ems);
			print(sph.refl);
		}
	}
}
