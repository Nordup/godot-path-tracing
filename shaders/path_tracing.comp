#version 460 core


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;




/* ====================== STRUCTS ====================== */


struct Sphere
{
	vec4 pos;
	vec4 clr;
	float r;
};




/* ====================== OUPUT BUFFERS ====================== */


layout(set = 0, binding = 0, std430) buffer ColorBuffer
{
	vec4 pixel[];
} color_buffer;


layout(set = 0, binding = 1, std430) buffer DebugBuffer
{
	float data[];
} debug_buffer;




/* ====================== INPUT BUFFERS ====================== */


layout(set = 1, binding = 0, std140) buffer Camera
{
	vec4 pos;
	vec4 rot;
	float fov;
} camera;


layout(set = 1, binding = 1, std430) buffer SphereBuffer
{
	Sphere[] sphere;
} sphere_buffer;




/* ====================== GLOBAL CONSTS ====================== */


uint width = gl_NumWorkGroups.x;
uint height = gl_NumWorkGroups.y;




/* ====================== FUNCTIONS ====================== */


// Debug

int printI = 0;

void print(float a)
{
	debug_buffer.data[printI] = a;
	printI++;
}


void printAt(float a, int index)
{
	debug_buffer.data[index] = a;
}



// Main

vec4 color(float x, float y)
{
	vec4 r1 = vec4(1, 1, 1, 1);
	vec4 r2 = vec4(0, 1, 1, 1);
	vec4 r3 = vec4(1, 0, 1, 1);
	vec4 r4 = vec4(1, 1, 0, 1);

	vec4 res = r1 * (1 - x) * (1 - y) + r2 * x * (1 - y) + r3 * (1 - x) * y + r4 * x * y;
	return res;
}


vec4 get_cam_ray(uint idx, uint idy)
{
	float fovA = radians(90 - camera.fov / 2); // Angle of between camera and axis
	float camX = cos(fovA);
	float camZ = -sin(fovA);
	float dX = 2 * camX / width;
	float dY = dX;
	float camY = (height / 2) * dY;

	vec4 baseRay = vec4(
		-camX + dX * idx,
		camY - dY * idy,
		camZ,
		0
	);

	float x = radians(camera.rot.x);
	float y = radians(camera.rot.z);
	float z = radians(camera.rot.z);
	mat4 rotMat = mat4(
		vec4(cos(y) * cos(z),	sin(x) * sin(y) * cos(z) - cos(x) * sin(z),		cos(x) * sin(y) * cos(z) + sin(x) * sin(z),		0),
		vec4(cos(y) * sin(z),	sin(x) * sin(y) * sin(z) + cos(x) * cos(z),		cos(x) * sin(y) * sin(z) - sin(x) * cos(z),		0),
		vec4(-sin(y),			sin(x) * cos(y),								cos(x) * cos(y),								0),
		vec4(0,					0,												0,												1)
	);

	vec4 ray = rotMat * baseRay;
	return ray;
}


void main()
{
	uint idx = gl_GlobalInvocationID.x;
	uint idy = gl_GlobalInvocationID.y;
	
	vec4 ray = get_cam_ray(idx, idy);
	float dx = float(idx) / width;
	float dy = float(idy) / height;
	color_buffer.pixel[idx + idy * width].rgba = color(dx, dy);


	// Debug

	if (idx == 0 && idy == 0){
		print(ray.x);
		print(ray.y);
		print(ray.z);
		print(ray.w);
	}
}
