#version 460 core


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;




/* ====================== STRUCTS ====================== */


struct Sphere
{
	vec4 pos;
	float rad;
	vec4 clr;
	vec4 ems; // emission
	float refl; // reflection type (DIFFuse, SPECular, REFRactive)
};


struct Ray
{
	vec4 pos;
	vec4 dir;
};




/* ====================== OUPUT BUFFERS ====================== */


layout(set = 0, binding = 0, std430) buffer ColorBuffer
{
	vec4 pixel[];
} color_buffer;


layout(set = 0, binding = 1, std430) buffer DebugBuffer
{
	float data[];
} debug_buffer;




/* ====================== INPUT BUFFERS ====================== */


layout(set = 1, binding = 0, std140) buffer Camera
{
	vec4 pos;
	vec4 rot;
	float fov;
} camera;


layout(set = 1, binding = 1, std140) buffer SphereBuffer
{
	Sphere[] sphere;
} sphere_buffer;




/* ====================== GLOBAL CONSTS ====================== */


uint idx = gl_GlobalInvocationID.x;
uint idy = gl_GlobalInvocationID.y;
uint width = gl_NumWorkGroups.x;
uint height = gl_NumWorkGroups.y;


// Reflection type (DIFFuse, SPECular, REFRactive)

const float DIFF = 0;
const float SPEC = 1;
const float REFR = 2;



/* ====================== FUNCTIONS ====================== */


// Debug

int pIndex = 0;


void print(float f)
{
	debug_buffer.data[pIndex] = 1;
	debug_buffer.data[pIndex + 1] = f;
	pIndex += 2;
}


void print4(vec4 vec)
{
	debug_buffer.data[pIndex] = 4;
	debug_buffer.data[pIndex + 1] = vec.x;
	debug_buffer.data[pIndex + 2] = vec.y;
	debug_buffer.data[pIndex + 3] = vec.z;
	debug_buffer.data[pIndex + 4] = vec.w;
	pIndex += 5;
}



// Main


Ray get_cam_ray(uint idx, uint idy)
{
	float fovA = radians(camera.fov / 2);
	float camX = sin(fovA);
	float camZ = -cos(fovA);
	float dX = 2 * camX / width;
	float dY = dX;
	float camY = (height / 2) * dY;

	vec3 baseRay = vec3(
		-camX + dX * idx,
		camY - dY * idy,
		camZ
	);

	// rotated_vec = vec + 2.0 * cross(cross(vec, quat.xyz) + quat.w * vec, quat.xyz)
	vec3 rotated = baseRay + 2.0 * cross(cross(baseRay, camera.rot.xyz)
										+ camera.rot.w * baseRay, camera.rot.xyz);
	return Ray(camera.pos, vec4(normalize(rotated), 1));
}


double intersect_sphere(const Ray r, const Sphere s)
{								// returns distance, 0 if nohit
	vec4 op = s.pos - r.pos;	// Solve t^2*d.d + 2*t*(o-p).d + (o-p).(o-p)-R^2 = 0
	double t, eps = 1e-4;
	double b = dot(op, r.dir);
	double det = b * b - dot(op, op) + s.rad * s.rad;
	if (det < 0)
		return 0;
	else
		det = sqrt(det);
	return (t = b - det) > eps ? t : ((t = b + det) > eps ? t : 0);
}


bool intersect(const Ray r, inout double t, inout int id)
{
	double d;
	double inf = t = 1e20;
	for (int i = 0; i < sphere_buffer.sphere.length(); i++)
	{
		d = intersect_sphere(r, sphere_buffer.sphere[i]);
		if (d != 0 && d < t)
		{
			t = d;
			id = i;
		}
	}
	return t < inf;
}


void main()
{
	double t;
	int id;

	Ray ray = get_cam_ray(idx, idy);
	if (intersect(ray, t, id))
		color_buffer.pixel[idx + idy * width] = sphere_buffer.sphere[id].clr;
	else
		color_buffer.pixel[idx + idy * width] = vec4(0, 0, 0, 1);


	// Debug

	if (idx == 0 && idy == 0)
	{
		
	}
}
