#version 460 core


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;




/* ====================== STRUCTS ====================== */


struct Sphere
{
	vec4 pos;
	vec4 clr;
	float r;
};




/* ====================== OUPUT BUFFERS ====================== */


layout(set = 0, binding = 0, std430) buffer ColorBuffer
{
	vec4 pixel[];
} color_buffer;


layout(set = 0, binding = 1, std430) buffer DebugBuffer
{
	float data[];
} debug_buffer;




/* ====================== INPUT BUFFERS ====================== */


layout(set = 1, binding = 0, std140) buffer Camera
{
	vec4 pos;
	vec4 rot;
	float fov;
} camera;


layout(set = 1, binding = 1, std430) buffer SphereBuffer
{
	Sphere[] sphere;
} sphere_buffer;




/* ====================== GLOBAL CONSTS ====================== */


uint idx = gl_GlobalInvocationID.x;
uint idy = gl_GlobalInvocationID.y;
uint width = gl_NumWorkGroups.x;
uint height = gl_NumWorkGroups.y;




/* ====================== FUNCTIONS ====================== */


// Debug

int printI = 0;


void print(float a)
{
	debug_buffer.data[printI] = a;
	printI++;
}


void print_vec4(vec4 v)
{
	print(v.x);
	print(v.y);
	print(v.z);
	print(v.w);
}


void printAt(float a, int index)
{
	debug_buffer.data[index] = a;
}



// Main

mat4 rot_mat_x(float angle)
{
	return mat4(
		vec4(1,	0,			0,				0),
		vec4(0,	cos(angle), -sin(angle),	0),
		vec4(0,	sin(angle), cos(angle),		0),
		vec4(0,	0,			0,				1)
	);
}


mat4 rot_mat_y(float angle)
{
	return mat4(
		vec4(cos(angle),	0,			sin(angle),	0),
		vec4(0,				1,			0,			0),
		vec4(-sin(angle),	0,			cos(angle), 0),
		vec4(0,				0,			0,			1)
	);
}


mat4 rot_mat_z(float angle)
{
	return mat4(
		vec4(cos(angle),	-sin(angle),	0, 0),
		vec4(sin(angle),	cos(angle),		0, 0),
		vec4(0,				0,				1, 0),
		vec4(0,				0,				0, 1)
	);
}


vec4 rotate_vector(vec4 rot, vec4 vec)
{
	rot = -rot; // change clockwise
	return rot_mat_y(rot.y) * rot_mat_x(rot.x) * rot_mat_z(rot.z) * vec;
}


vec4 get_cam_ray(uint idx, uint idy)
{
	float fovA = radians(camera.fov / 2);
	float camX = sin(fovA);
	float camZ = -cos(fovA);
	float dX = 2 * camX / width;
	float dY = dX;
	float camY = (height / 2) * dY;

	vec4 baseRay = vec4(
		-camX + dX * idx,
		camY - dY * idy,
		camZ,
		1
	);

	vec4 ray = rotate_vector(camera.rot, baseRay);
	return ray;
}


vec4 color(float x, float y)
{
	vec4 r1 = vec4(1, 1, 1, 1);
	vec4 r2 = vec4(0, 1, 1, 1);
	vec4 r3 = vec4(1, 0, 1, 1);
	vec4 r4 = vec4(1, 1, 0, 1);

	vec4 res = r1 * (1 - x) * (1 - y) + r2 * x * (1 - y) + r3 * (1 - x) * y + r4 * x * y;
	return res;
}


void main()
{
	vec4 ray = get_cam_ray(idx, idy);
	float dx = float(idx) / width;
	float dy = float(idy) / height;
	color_buffer.pixel[idx + idy * width].rgba = color(dx, dy);


	// Debug

	if (idx == 0 && idy == 0)
	{
		print_vec4(ray);
		// print_vec4(camera.rot);
	}
}
