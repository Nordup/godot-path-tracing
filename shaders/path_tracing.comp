#version 460 core


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;




/* ====================== STRUCTS ====================== */


struct Sphere
{
	vec4 pos;
	vec4 clr;
	float r;
};




/* ====================== OUPUT BUFFERS ====================== */


layout(set = 0, binding = 0, std430) buffer ColorBuffer
{
	vec4 pixel[];
} color_buffer;


layout(set = 0, binding = 1, std430) buffer DebugBuffer
{
	float data[];
} debug_buffer;




/* ====================== INPUT BUFFERS ====================== */


layout(set = 1, binding = 0, std140) buffer Camera
{
	vec4 pos;
	vec4 rot;
	float fov;
} camera;


layout(set = 1, binding = 1, std430) buffer SphereBuffer
{
	Sphere[] sphere;
} sphere_buffer;




/* ====================== GLOBAL CONSTS ====================== */


uint idx = gl_GlobalInvocationID.x;
uint idy = gl_GlobalInvocationID.y;
uint width = gl_NumWorkGroups.x;
uint height = gl_NumWorkGroups.y;




/* ====================== FUNCTIONS ====================== */


// Debug

int printI = 0;


void print(float a)
{
	debug_buffer.data[printI] = a;
	printI++;
}


void print_vec4(vec4 v)
{
	print(v.x);
	print(v.y);
	print(v.z);
	print(v.w);
}


void printAt(float a, int index)
{
	debug_buffer.data[index] = a;
}



// Main


vec3 rotate_vector(vec3 vec, vec3 euler)
{
	mat4 rmat_x = mat4(
		vec4(1,	0,			0,				0),
		vec4(0,	cos(euler.x), -sin(euler.x),	0),
		vec4(0,	sin(euler.x), cos(euler.x),		0),
		vec4(0,	0,			0,				1)
	);
	mat4 rmat_y = mat4(
		vec4(cos(euler.y),	0,			sin(euler.y),	0),
		vec4(0,				1,			0,			0),
		vec4(-sin(euler.y),	0,			cos(euler.y), 0),
		vec4(0,				0,			0,			1)
	);
	mat4 rmat_z = mat4(
		vec4(cos(euler.z),	-sin(euler.z),	0, 0),
		vec4(sin(euler.z),	cos(euler.z),		0, 0),
		vec4(0,				0,				1, 0),
		vec4(0,				0,				0, 1)
	);
	vec4 res = rmat_y * rmat_x * rmat_z * vec4(vec, 1);
	return res.xyz;
}


vec3 rotate_vector(vec3 vec, vec4 quat)
{
	return vec + 2.0 * cross(cross(vec, quat.xyz) + quat.w * vec, quat.xyz);
}


vec4 get_cam_ray(uint idx, uint idy)
{
	float fovA = radians(camera.fov / 2);
	float camX = sin(fovA);
	float camZ = -cos(fovA);
	float dX = 2 * camX / width;
	float dY = dX;
	float camY = (height / 2) * dY;

	vec3 baseRay = vec3(
		-camX + dX * idx,
		camY - dY * idy,
		camZ
	);
	return vec4(rotate_vector(baseRay, camera.rot), 1);
}


void main()
{
	vec4 ray = get_cam_ray(idx, idy);
	color_buffer.pixel[idx + idy * width] = ray;


	// Debug

	if (idx == 0 && idy == 0)
	{
		// print_vec4(camera.rot);
		// print_vec4(ray);
	}
}
